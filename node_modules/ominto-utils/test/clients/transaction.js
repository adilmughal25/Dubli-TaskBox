'use strict';

const transaction = require('../../src/clients/transaction')(configs);
const USER_ID = 123;
const SOURCE_ID = 123432;
const GATEWAY = 'testGateway';
const FEES = 1;
const SOURCE_TYPE = 'bank_acct';
const TYPE = 'master_withdrawal';
const AMOUNT = '1234';
const STATE = 'paid';
const CURRENCY = 'USD';

let sandbox, masterWithdrawal, withdrawalDetails;

describe('The transaction client', () => {

  beforeEach(done => {
    co(function*() {
      sandbox = sinon.sandbox.create();
      masterWithdrawal = {
        source_transaction_id: 'GatewayId',
        currency: 'usd',
        state: 'paid',
        date_initiated: '2015-10-26T20:36:38.000Z',
        amount_fees: 0,
        user_id: 123,
        gateway: 'stripe',
        type: 'withdrawal_detail',
        source_type: 'stripe',
        amount_to_user: -357,
        date_paid: '2015-10-26T20:36:38.000Z',
        conversion_rate: 1.5
      };

      withdrawalDetails = [{
        source_transaction_id: '',
        currency: 'eur',
        state: 'paid',
        date_initiated: '2015-10-26T20:36:38.000Z',
        amount_fees: 0,
        user_id: 123,
        gateway: 'stripe',
        type: 'withdrawal_detail',
        source_type: 'stripe',
        amount_to_user: -123,
        date_paid: '2015-10-26T20:36:38.000Z',
        conversion_rate: 1
      }, {
        source_transaction_id: '',
        currency: 'cdn',
        state: 'paid',
        date_initiated: '2015-10-26T20:36:38.000Z',
        amount_fees: 0,
        user_id: 123,
        gateway: 'stripe',
        type: 'withdrawal_detail',
        source_type: 'stripe',
        amount_to_user: -234,
        date_paid: '2015-10-26T20:36:38.000Z',
        conversion_rate: 1
      }];
      done();
    }).catch(done);
  });

  afterEach(() => {
    sandbox.restore();
    nock.cleanAll();
  });

  it('should be an object', () => {
    expect(transaction).to.be.a('object');
  });

  describe.skip('prepareWithdrawalsForOmintoPayment', () => {

    it('returns updated withdrawal details for ominto payment', done => {
      co(function*() {
        let conversionRate = 1;
        let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=cdn').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=cdn&to=usd').reply(200, {
          rate: conversionRate
        });
        let actual = yield transaction.prepareWithdrawalsForOmintoPayment(withdrawalDetails, 99, mock_koa);
        expect(actual.length).to.eql(1);
        expect(actual[0].amount_to_user).to.eql(-99);
        expect(actual[0].source_type).to.eql('ominto');
        done();
      }).catch(done);
    });

    it('returns both transactions in their entirety with unchanged amount_to_user values if the value going in exactly equals the amounts available, changing the source_type to ominto', done => {
      co(function*() {
        let conversionRate = 1;
        let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=cdn').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=cdn&to=usd').reply(200, {
          rate: conversionRate
        });
        let actual = yield transaction.prepareWithdrawalsForOmintoPayment(withdrawalDetails, 357, mock_koa);
        expect(actual.length).to.eql(2);
        expect(actual[1].amount_to_user).to.eql(-123);
        expect(actual[0].amount_to_user).to.eql(-234);
        expect(actual[0].source_type).to.eql('ominto');
        expect(actual[1].source_type).to.eql('ominto');
        done();
      }).catch(done);
    });

  it('returns empty array if insufficient funds are available', done => {
      co(function*() {
        let conversionRate = 1;
        let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=cdn').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=cdn&to=usd').reply(200, {
          rate: conversionRate
        });
        let actual = yield transaction.prepareWithdrawalsForOmintoPayment(withdrawalDetails, 358, mock_koa);

        expect(actual.length).to.eql(0);
        expect(actual).to.eql([]);
        done();
      }).catch(done);
    });
  });

  describe('createWithdrawalRequestBody', () => {

    it('returns a transaction object', done => {
      co(function*() {
        let actual = yield transaction.createWithdrawalRequestBody(USER_ID, GATEWAY, SOURCE_ID, CURRENCY, FEES,
          SOURCE_TYPE, TYPE, AMOUNT, STATE);
        expect(actual.user_id).to.equal(USER_ID);
        expect(actual.source_transaction_id).to.equal(SOURCE_ID);
        expect(actual.gateway).to.equal(GATEWAY);
        expect(actual.amount_fees).to.equal(FEES);
        expect(actual.amount_to_user).to.equal(AMOUNT * -1);
        expect(actual.state).to.equal(STATE);
        expect(actual.type).to.equal(TYPE);
        done();
      }).catch(done);
    });
  });

  describe('lockWithdrawal', () => {

    it('returns true for successful lock', done => {
      co(function*() {
        let lock = nock(configs.data_api.internalUrl).post('/lockWithdrawal/123/').reply(201);
        let actual = yield transaction.lockWithdrawal(USER_ID, mock_koa);
        expect(actual).to.be.true;
        lock.done();
        done();
      }).catch(done);
    });

    it('throws an error for a failed lock', done => {
      let lock = nock(configs.data_api.internalUrl).post('/lockWithdrawal/123/').reply(400);
      co(function*() {
        yield transaction.lockWithdrawal(USER_ID, mock_koa);
        done('Should not make it here');
      }).catch(err => {
        expect(err.internalCode).to.equal(376);
        expect(err.userId).to.equal(USER_ID);
        expect(err.res).to.exist;
        lock.done();
        done();
      }).catch(done);
    });
  });

  describe('unlockWithdrawal', () => {

    it('returns true for successful unlock', done => {
      co(function*() {
        let lock = nock(configs.data_api.internalUrl).delete('/unlockWithdrawal/123/').reply(200);
        let actual = yield transaction.unlockWithdrawal(USER_ID, mock_koa);
        expect(actual).to.be.true;
        lock.done();
        done();
      }).catch(done);
    });

    it('throws an error for a failed lock', done => {
      let lock = nock(configs.data_api.internalUrl).delete('/unlockWithdrawal/123/').reply(400);
      co(function*() {
        yield transaction.unlockWithdrawal(USER_ID, mock_koa);
        done('Should not make it here');
      }).catch(err => {
        expect(err.internalCode).to.equal(377);
        expect(err.userId).to.equal(USER_ID);
        expect(err.res).to.exist;
        lock.done();
        done();
      }).catch(done);
    });
  });

  describe('determineFromCurrency', () => {

    it('returns array of currencies if one exists in the incoming request.fromCurrency parameter', done => {
      co(function*() {
        let request = {
          fromCurrencies: ['gbp', 'eur']
        };
        let user = {
          currency: 'aed'
        };
        let defaultCurrency = 'usd';

        let actual = yield transaction.determineFromCurrency(request, user, defaultCurrency);
        expect(actual).to.eql(request.fromCurrencies);
        done();
      }).catch(done);
    });

    it('returns users currency if request.fromCurrencies is passed but empty', done => {
      co(function*() {
        let request = {
          fromCurrencies: []
        };
        let user = {
          currency: 'aed'
        };
        let defaultCurrency = 'usd';

        let actual = yield transaction.determineFromCurrency(request, user, defaultCurrency);
        expect(actual).to.eql(user.currency);
        done();
      }).catch(done);
    });

    it('returns users currency value if no fromCurrency is attached to the request', done => {
      co(function*() {
        let request = {};
        let user = {
          currency: 'usd'
        };
        let defaultCurrency = 'usd';

        let actual = yield transaction.determineFromCurrency(request, user, defaultCurrency);
        expect(actual).to.eql(user.currency);
        done();
      }).catch(done);
    });

    it('returns default if user has a null currency', done => {
      co(function*() {
        let request = {};
        let user = {
          currency: null
        };
        let defaultCurrency = 'usd';

        let actual = yield transaction.determineFromCurrency(request, user, defaultCurrency);
        expect(actual).to.eql(defaultCurrency);
        done();
      }).catch(done);
    });

    it('returns default currency if non is associated to the request or user', done => {
      co(function*() {
        let request = {};
        let user = {
          id: 1233
        };
        let defaultCurrency = 'eur';

        let actual = yield transaction.determineFromCurrency(request, user, defaultCurrency);
        expect(actual).to.eql(defaultCurrency);
        done();
      }).catch(done);
    });
  });

  describe('getAvailableBalanceForWithdrawalForUserByCurrencies', () => {

    it('returns list of "withdrawal_detail" transactions and available object containing converted total and' +
      ' currency for withdrawal', done => {
      let mockBalancesResponse = [{
        currency: 'eur',
        total: 123
      }, {
        currency: 'gbp',
        total: 234
      }];

      let expectedAvailableBalance = Math.floor(mockBalancesResponse[0].total * 1.5 +
        mockBalancesResponse[1].total * 2);

      let getBalancesForCurrencies =
        nock(configs.data_api.internalUrl)
          .get('/getAvailableBalanceForWithdrawalForUserByCurrencies/123/').reply(200,
          mockBalancesResponse).
          post('/convertCurrencies').reply(200, [{amount: 1.23 * 1.5},{amount: 2.34 * 2}])
          .get('/getConversionRate/?from=eur&to=usd').reply(200, {
            rate: 1.5
          })
          .get('/getConversionRate/?from=gbp&to=usd').reply(200, {
            rate: 2
          });
      co(function*() {
        let fromCurrencies = ['gbp', 'eur'];
        let toCurrency = 'usd';
        let userId = 123;
        let gateway = 'stripe';

        let actual = yield transaction.getAvailableBalanceForWithdrawalForUserByCurrencies(fromCurrencies, toCurrency,
          userId, gateway, mock_koa);

        expect(actual.transactions[0].currency).to.equal('eur');
        expect(actual.transactions[0].state).to.equal('paid');
        expect(actual.transactions[0].gateway).to.equal('stripe');
        expect(actual.transactions[0].type).to.equal('withdrawal_detail');
        expect(actual.transactions[0].amount_to_user).to.equal(-123);
        expect(actual.transactions[0].conversion_rate).to.equal(1.5);

        expect(actual.transactions[1].currency).to.equal('gbp');
        expect(actual.transactions[1].state).to.equal('paid');
        expect(actual.transactions[1].gateway).to.equal('stripe');
        expect(actual.transactions[1].type).to.equal('withdrawal_detail');
        expect(actual.transactions[1].amount_to_user).to.equal(-234);
        expect(actual.transactions[1].conversion_rate).to.equal(2);

        expect(actual.available.currency).to.equal(toCurrency);
        expect(actual.available.amount).to.equal(expectedAvailableBalance);
        // expect(actual).to.eql('test');

        getBalancesForCurrencies.done();

        done();
      }).catch(done);
    });
    it('returns list of "withdrawal_detail" transactions and available object containing converted total and' +
      ' currency for withdrawal', done => {
      let fromCurrencies = ['gbp', 'eur'];
      let toCurrency = 'usd';
      let userId = 123;
      let gateway = 'stripe';

      let getBalancesForCurrencies =
        nock(configs.data_api.internalUrl)
          .get('/getAvailableBalanceForWithdrawalForUserByCurrencies/' + userId + '/').reply(404);
      co(function*() {

        yield transaction.getAvailableBalanceForWithdrawalForUserByCurrencies(fromCurrencies, toCurrency,
          userId, gateway, mock_koa);

        // expect(actual).to.eql('test');
        done();
      }).catch(err => {
        expect(err.internalCode).to.equal(378);
        expect(err.name).to.equal('BadRequestError');
        expect(err.message).to.equal('No eligible transactions found for this withdrawal');
        expect(err.fromCurrencies).to.equal(fromCurrencies);
        expect(err.userId).to.equal(123);
        expect(err.res).to.exist;
        getBalancesForCurrencies.done();
        done();
      }).catch(done);
    });
  });

  describe('createTransactionsForWithdrawal', () => {

    it('returns list of master_withdrawal and its associated withdrawal_details for this withdrawal', done => {

      let mockMasterWithdrawalCreateResponse = {
        id: 15
      };
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl)
        .post('/createTransaction/').reply(201, mockMasterWithdrawalCreateResponse)
        .post('/createTransactions/').reply(201, {id: 16})
        .post('/createTransactions/').reply(201, {id: 17});
      co(function*() {
        let actual = yield transaction.createTransactionsForWithdrawal(masterWithdrawal, withdrawalDetails, mock_koa);
        expect(actual).to.eql([{id: 15}, {id: 16}, {id: 17}]);
        createWithdrawalTransactions.done();

        done();
      }).catch(done);
    });

    it('returns an error if the master withdrawal is not created successfully', done => {
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl).post('/createTransaction/').reply(400);
      co(function*() {
        yield transaction.createTransactionsForWithdrawal(masterWithdrawal, withdrawalDetails, mock_koa);

        done('Should not make it here');
      }).catch(err => {
        expect(err.message).to.eql('Unexpected result from data service during createTransaction');
        expect(err.internalCode).to.eql(351);
        expect(err.transactionFields).to.eql(masterWithdrawal);
        expect(err.res).to.exist;
        createWithdrawalTransactions.done();
        done();
      }).catch(done);
    });

    it('returns an error if the master withdrawal is a duplicate', done => {
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl).post('/createTransaction/').reply(400,
        {code: 'ER_DUP_ENTRY'});
      co(function*() {
        yield transaction.createTransactionsForWithdrawal(masterWithdrawal, withdrawalDetails, mock_koa);

        done('Should not make it here');
      }).catch(err => {
        expect(err.message).to.eql('Unique field already in use');
        expect(err.internalCode).to.eql(52);
        expect(err.duplicateKey).to.be.true;
        createWithdrawalTransactions.done();
        done();
      }).catch(done);
    });

    it('returns an error if the withdrawal details are not created successfully', done => {
      let mockMasterWithdrawalCreateResponse = {
        id: 15
      };
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl).post('/createTransaction/').reply(201,
        mockMasterWithdrawalCreateResponse).post('/createTransactions/').reply(400);
      co(function*() {
        yield transaction.createTransactionsForWithdrawal(masterWithdrawal, withdrawalDetails, mock_koa);

        done('Should not make it here');
      }).catch(err => {
        expect(err.message).to.eql('Unexpected result from data service during createTransaction');
        expect(err.internalCode).to.eql(351);
        expect(err.transactionFields).to.eql(withdrawalDetails[0]);
        expect(err.res).to.exist;
        createWithdrawalTransactions.done();
        done();
      }).catch(done);
    });

    it('returns an error if the withdrawal details are duplicates', done => {
      let mockMasterWithdrawalCreateResponse = {
        id: 15
      };
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl).post('/createTransaction/').reply(201,
        mockMasterWithdrawalCreateResponse).post('/createTransactions/').reply(400,
        {code: 'ER_DUP_ENTRY'});
      co(function*() {
        yield transaction.createTransactionsForWithdrawal(masterWithdrawal, withdrawalDetails, mock_koa);

        done('Should not make it here');
      }).catch(err => {
        expect(err.message).to.eql('Unique field already in use');
        expect(err.internalCode).to.eql(52);
        expect(err.duplicateKey).to.be.true;
        createWithdrawalTransactions.done();
        done();
      }).catch(done);
    });
  });

  describe('createWithdrawalDetailTransactions', () => {

    it('returns list of withdrawal_details for this withdrawal', done => {
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl)
        .post('/createTransactions/').reply(201, {id: 16})
        .post('/createTransactions/').reply(201, {id: 17});
      co(function*() {
        let actual = yield transaction.createWithdrawalDetailTransactions(withdrawalDetails, mock_koa);
        expect(actual).to.eql([{id: 16}, {id: 17}]);
        createWithdrawalTransactions.done();

        done();
      }).catch(done);
    });

    it('returns an error if a withdrawal is not created successfully', done => {
      let createWithdrawalTransactions = nock(configs.data_api.internalUrl).post('/createTransactions/').reply(400);
      co(function*() {
        yield transaction.createWithdrawalDetailTransactions(withdrawalDetails, mock_koa);

        done('Should not make it here');
      }).catch(err => {
        expect(err.message).to.eql('Unexpected result from data service during createTransaction');
        expect(err.internalCode).to.eql(351);
        expect(err.transactionFields).to.eql(withdrawalDetails[0]);
        expect(err.res).to.exist;
        createWithdrawalTransactions.done();
        done();
      }).catch(done);
    });
  });

  describe('aggregateAvailableBalance', () => {
    it('returns balance object in appropriate format for convertCurrency from available balances from data', done => {
      let mockResponse = [{total: 50, currency: 'eur'}, {total: 50, currency: 'usd'}];
      co(function*() {
        let actual = yield transaction.aggregateAvailableBalance(mockResponse);
        expect(actual).to.eql({eur: {available: 50}, usd: {available: 50}});
        done();
      }).catch(done);
    });

    it('handles single values for input', done => {
      let mockResponse = [{
        total: 50,
        currency: 'usd'
      }];
      co(function*() {
        let actual = yield transaction.aggregateAvailableBalance(mockResponse);

        expect(actual).to.eql({
          usd: {
            available: 50
          }
        });
        done();
      }).catch(done);
    });

    it('adds values of the same currency together if it receives multiple', done => {
      let mockResponse = [{
        total: 50,
        currency: 'usd'
      }, {
        total: 50,
        currency: 'usd'
      }];
      co(function*() {
        let actual = yield transaction.aggregateAvailableBalance(mockResponse);

        expect(actual).to.eql({
          usd: {
            available: 100
          }
        });
        done();
      }).catch(done);
    });
  });

  describe('setSourceTransactionForWithdrawalDetails', () => {

    it('returns array of withdrawal_detail transactions with source_transaction_id set to the id of the' +
      ' master_withdrawal', done => {
      let masterWithdrawalId = '15';
      co(function*() {
        let actual = yield transaction.setSourceTransactionForWithdrawalDetails(masterWithdrawalId,
          withdrawalDetails);
        expect(actual).to.be.an('array');
        expect(actual[0].source_transaction_id).to.equal(masterWithdrawalId);
        expect(actual[1].source_transaction_id).to.equal(masterWithdrawalId);
        expect(_.omit(actual, 'source_transaction_id')).to.eql(_.omit(withdrawalDetails, 'source_transaction_id'));
        done();
      }).catch(done);
    });
  });

  describe('getBalanceForUser', () => {

    it('returns available and pending balance per currency that a given userId has', done => {

      let mockResponse = [{currency: 'eur', pending: 53, available: 159},
        {currency: 'usd', pending: 96, available: 12}];
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(200, mockResponse);
      co(function*() {
        let actual = yield transaction.getBalanceForUser(1, mock_koa);
        expect(actual).to.eql(mockResponse);
        getBalanceForUser.done();
        done();
      }).catch(done);
    });

    it('returns available and pending balance for only one currency if user only has one currency', done => {

      let mockResponse = [{currency: 'eur', pending: 53, available: 159}];
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(200, mockResponse);
      co(function*() {
        let actual = yield transaction.getBalanceForUser(1, mock_koa);
        expect(actual).to.eql(mockResponse);
        getBalanceForUser.done();
        done();
      }).catch(done);
    });

    it('returns an empty array if user has no balances yet', done => {

      let mockResponse = [];
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(200, mockResponse);
      co(function*() {
        let actual = yield transaction.getBalanceForUser(1, mock_koa);
        expect(actual).to.eql(mockResponse);
        getBalanceForUser.done();
        done();
      }).catch(done);
    });

    it('returns an error if a non 200 is returned from data', done => {

      let mockResponse = [];
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(500);
      co(function*() {
        let actual = yield transaction.getBalanceForUser(1, mock_koa);
        expect(actual).to.eql(mockResponse);
        getBalanceForUser.done();
        done();
      }).catch(err => {
        expect(err.name).to.eql('InternalServerError');
        expect(err.message).to.equal('Unexpected result from data service during getBalanceForUser');
        expect(err.internalCode).to.eql(351);
        expect(err.userId).to.eql(1);
        expect(err.res).to.exist;
        done();
      }).catch(done);
    });
  });

  describe('getLocalizedBalanceForUser', () => {

    it('returns pending, escrowed, available and total balance converted to localized currency for a user', done => {
      let localizedCurrency = 'usd';
      let rate = 100;
      let mockResponse = {eur: {pending: 53, available: 159}, usd: {pending: 96, available: 12}};
      let expectedPending = ((mockResponse.eur.pending * rate) + mockResponse.usd.pending);
      let expectedAvailable = (mockResponse.eur.available * rate + mockResponse.usd.available);
      let expectedTotal = expectedPending + expectedAvailable;
      let expected = {escrowed: 0, pending: expectedPending, available: expectedAvailable, total: expectedTotal};
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(200, mockResponse)
        .post('/convertCurrencies').reply(200, [{amount: 0.53 * rate}])
        .post('/convertCurrencies').reply(200, [{amount: 1.59 * rate}]);
      co(function*() {
        let actual = yield transaction.getLocalizedBalanceForUser(1, localizedCurrency, mock_koa);

        expect(actual).to.eql(expected);
        getBalanceForUser.done();
        done();
      }).catch(done);
    });

    it('does no conversion if the localized currency is the only currency they have a balance in', done => {
      let localizedCurrency = 'usd';
      let mockResponse = {usd: {pending: 96, available: 12}};
      let expected = {available: 12,escrowed: 0, pending: 96, total: 108};
      let getBalanceForUser = nock(configs.data_api.internalUrl)
        .get('/getBalanceForUser/1/').reply(200, mockResponse);
      co(function*() {
        let actual = yield transaction.getLocalizedBalanceForUser(1, localizedCurrency, mock_koa);

        expect(actual).to.eql(expected);
        getBalanceForUser.done();
        done();
      }).catch(done);
    });
  });
});
