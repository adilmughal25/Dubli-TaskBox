"use strict";

describe('utils/currency', () => {
  let currencyUtil = require('../../src/utils/currency');
  let getIntFunc = currencyUtil.getIntegerAmountForCurrency;
  let convertCurrency = currencyUtil.convertCurrency;
  let convertCurrencyForPayment = currencyUtil.convertCurrencyForPayment;
  let getMinorAmountForPackage = currencyUtil.getMinorAmountForPackage;
  let aggregateUniqueCurrenciesForTransactions = currencyUtil.aggregateUniqueCurrenciesForTransactions;
  let subtractFromCurrency = currencyUtil.subtractFromCurrency;

  describe('subtractFromCurrency', () => {
    it('is available as a function', () => {
      expect(subtractFromCurrency).to.be.a('function');
    });

    it('returns object containing relevant values for conversion and subtraction ', done => {
        let conversionRate = 1;
        let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
          rate: conversionRate
        }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
          rate: conversionRate
        });
        let expected = {remaining: 49, subtracted: 50, incomingAs: 99, convertedIncoming: 99};
        co(function* () {
          let actual = yield subtractFromCurrency('eur', 'usd', 50, 99, mock_koa);
        expect(actual).to.eql(expected);
        done();
      }).catch(done);
    });

    it('returns remaining value if the incoming value is not reduced to zero', done => {
      let conversionRate = 1;
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
        rate: conversionRate
      }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
        rate: 1
      });
      let expected = {
        remaining: 0,
        subtracted: 99,
        incomingAs: 99,
        convertedIncoming: 99
      };
      co(function*() {
        let actual = yield subtractFromCurrency('eur', 'usd', 100, 99, mock_koa);
        expect(actual).to.eql(expected);
        done();
      }).catch(done);
    });

    it('returns remaining value if the incoming value is reduced to zero', done => {
      let conversionRate = 1;
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=eur&to=usd').reply(200, {
        rate: conversionRate
      }).get('/getConversionRate/?from=usd&to=eur').reply(200, {
        rate: 1
      });
      let expected = {
        remaining: 0,
        subtracted: 100,
        incomingAs: 100,
        convertedIncoming: 100
      };
      co(function*() {
        let actual = yield subtractFromCurrency('eur', 'usd', 100, 100, mock_koa);
        expect(actual).to.eql(expected);
        done();
      }).catch(done);
    });
  });

  describe('getIntegerAmountForCurrency', () => {
    it('is available as a function', () => {
      expect(getIntFunc).to.be.a('function');
    });

    it('should return an integer for a usd string amount', () => {
      expect(getIntFunc('15.11', 'usd')).to.eql(1511);
    });

    it('should handle uppercase currency codes', () => {
      expect(getIntFunc('15.11', 'USD')).to.eql(1511);
    });

    it('should default to 2 after-decimal digits', () => {
      expect(getIntFunc('5.12')).to.eql(512);
    });

    it('should handle truncated decimal amounts', () => {
      expect(getIntFunc('5.1', 'usd')).to.eql(510);
    });

    it('should handle fractional pennies', () => {
      expect(getIntFunc('10.2222222', 'usd')).to.eql(1022);
    });

    it('should handle flat dollar amounts with no decimal', () => {
      expect(getIntFunc('10', 'usd')).to.eql(1000);
    });

    it('should handle bitcoin defined as xbt(one of two standards)', () => {
      expect(getIntFunc('10', 'xbt')).to.eql(1000000000);
    });

    it('should handle bitcoin defined as btc(the standard open exchange supports)', () => {
      expect(getIntFunc('10', 'btc')).to.eql(1000000000);
    });

    it('should handle bitcoin with decimals', () => {
      expect(getIntFunc('12.34567', 'btc')).to.eql(1234567000);
    });
  });

  describe('convertCurrency', () => {

    before(() => {
      nock.disableNetConnect();
    });
    after(() => {
      nock.cleanAll();
    });
    it('is available as a function', () => {
      expect(convertCurrency).to.be.a('function');
    });

    it('Makes a call to get the exchange rate for the two currencies', done => {
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: 2
      });

      co(function*() {
        yield convertCurrency(1, 'usd', 'inr', mock_koa);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('handles xbt', done => {
      let amount = 9900;
      let conversionRate = 0.004181;
      let expected = 41391900; // 8 minor digits for xbt -- this is 0.413919 bitcoins
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=xbt').reply(200, {
        rate: conversionRate
      });
      co(function*() {
        let actual = yield convertCurrency(amount, 'usd', 'xbt', mock_koa);
        expect(actual).to.eql(expected);
        expect(actual).to.eql(41391900);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns a value calculated by amount * rate rounded down to the nearest integer', done => {
      let amount = 1;
      let conversionRate = 2;
      let expected = Math.floor(amount * conversionRate);
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: conversionRate
      });
      co(function*() {
        let actual = yield convertCurrency(amount, 'usd', 'inr', mock_koa);
        expect(actual).to.eql(expected);
        expect(actual).to.eql(2);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns a value calculated by amount * rate rounded down to the nearest integer given a decimal conversion rate', done => {
      let amount = 1;
      let conversionRate = 2.123;
      let expected = Math.floor(amount * conversionRate);
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: conversionRate
      });
      co(function*() {
        let actual = yield convertCurrency(amount, 'usd', 'inr', mock_koa);
        expect(actual).to.eql(expected);
        expect(actual).to.eql(2);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns the value passed in if the from and to currency matches without making a call to get the currency exchange rate', done => {
      let amount = 1;

      co(function*() {
        let actual = yield convertCurrency(amount, 'usd', 'usd', mock_koa);
        expect(actual).to.eql(amount);
        done();
      }).catch(done);
    });
  });

  describe('convertCurrencyForPayment', () => {

    before(() => {
      nock.disableNetConnect();
    });
    after(() => {
      nock.cleanAll();
    });
    it('is available as a function', () => {
      expect(convertCurrencyForPayment).to.be.a('function');
    });

    it('Makes a call to get the exchange rate for the two currencies', done => {
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: 2
      });

      co(function*() {
        yield convertCurrencyForPayment(1, 'usd', 'inr', mock_koa);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns a value calculated by amount * rate rounded up to the nearest integer', done => {
      let amount = 1;
      let conversionRate = 2;
      let expected = Math.ceil(amount * conversionRate);
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: conversionRate
      });
      co(function*() {
        let actual = yield convertCurrencyForPayment(amount, 'usd', 'inr', mock_koa);
        expect(actual).to.eql(expected);
        expect(actual).to.eql(2);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns a value calculated by amount * rate rounded up to the nearest integer given a decimal conversion rate', done => {
      let amount = 1;
      let conversionRate = 2.123;
      let expected = Math.ceil(amount * conversionRate);
      let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
        rate: conversionRate
      });
      co(function*() {
        let actual = yield convertCurrencyForPayment(amount, 'usd', 'inr', mock_koa);
        expect(actual).to.eql(expected);
        expect(actual).to.eql(3);
        getConversionRate.done();
        done();
      }).catch(done);
    });

    it('returns the value passed in if the from and to currency matches without making a call to get the currency exchange rate', done => {
      let amount = 1;

      co(function*() {
        let actual = yield convertCurrencyForPayment(amount, 'usd', 'usd', mock_koa);
        expect(actual).to.eql(amount);
        done();
      }).catch(done);
    });
  });

  describe('purchasePackages client', () => {

    describe('getAmountForDeal', () => {

      before(() => {
        currencyUtil.init(configs);
        nock.disableNetConnect();
      });

      after(() => {
        nock.cleanAll();
      });

      it('is available as a function', () => {
        expect(getMinorAmountForPackage).to.be.a('function');
      });

      it('returns the result of Math.ceil(purchaseItem in minor amount * rate) for an existing item in purchaseItems', done => {
        let purchaseItem = 'vip';
        let rate = 66.20;
        let expected = Math.ceil(9900 * rate);

        let getConversionRate = nock(configs.data_api.internalUrl).get('/getConversionRate/?from=usd&to=inr').reply(200, {
          rate: rate
        });
        co(function*() {
          let actual = yield getMinorAmountForPackage(purchaseItem, 'INR', mock_koa);
          expect(actual).to.eql(655380); // always in integer amounts, calling .format currency on this amount will return 6,553.80
          expect(actual).to.eql(expected);
          expect(actual).to.be.a('number');
          getConversionRate.done();
          done();
        }).catch(done);
      });

      it('throws an error and makes no external calls if given a non existing purchase item', done => {
        let nonExistingPurchaseItem = 'I do not exist';
        co(function*() {
          yield getMinorAmountForPackage(nonExistingPurchaseItem, 'INR', mock_koa);
          done('Should not make it here');
        }).catch(err => {
          expect(err.message).to.equal('Purchase item does not exist');
          done();
        }).catch(done);
      });
    });

    describe('aggregateUniqueCurrenciesForTransactions', () => {

      before(() => {
        currencyUtil.init(configs);
        nock.disableNetConnect();
      });

      after(() => {
        nock.cleanAll();
      });

      it('is available as a function', () => {
        expect(getMinorAmountForPackage).to.be.a('function');
      });

      it('returns the result of Math.ceil(purchaseItem in minor amount * rate) for an existing item in purchaseItems', done => {
        let transactions = [{
          state: 'paid',
          amount_to_user: 100,
          currency: 'usd'
        }, {
          state: 'paid',
          amount_to_user: 201,
          currency: 'usd'
        }, {
          state: 'paid',
          amount_to_user: 100,
          currency: 'eur'
        }, {
          state: 'paid',
          amount_to_user: 11,
          currency: 'eur'
        }, {
          state: 'confirmed',
          amount_to_user: 1000,
          currency: 'usd'
        }];

        co(function*() {
          let actual = yield aggregateUniqueCurrenciesForTransactions(transactions, mock_koa);
          expect(actual.usd.available).to.eql(301);
          expect(actual.usd.pending).to.eql(1000);
          expect(actual.eur.available).to.eql(111);
          expect(actual.eur.pending).to.not.exist;
          done();
        }).catch(done);
      });
    });
  });
});
