/*global Intl*/
'use strict';

const _ = require('lodash');
const cc = require('currency-codes');
const Decimal = require('decimal');
const clients = require('../clients/clients');
let configs;

// load in latest ECMA-402 Intl API polyfill (used for currency formatting)
if (global.Intl) {
  // `Intl` exists, but it doesn't have the data we need, so load the
  // polyfill and patch the constructors we need with the polyfill's.
  var IntlPolyfill = require('intl');
  Intl.NumberFormat = IntlPolyfill.NumberFormat;
  Intl.DateTimeFormat = IntlPolyfill.DateTimeFormat;
} else {
  // No `Intl`, so use and load the polyfill.
  global.Intl = require('intl');
}

// please only pass me integer amounts in the smallest subdivision of the currency! thanks!
function localizeCurrency (amountInMinor, currency, language, ctx, digits) {
  if (!_.isString(currency) || currency.length !== 3) {
    ctx.state.logger.error({
      amountInMinor: amountInMinor,
      currency: currency,
      language: language
    }, "Invalid currency parameter passed to localizeCurrency");
    currency = 'usd';
  }

  if (!_.isString(language) || language.length !== 2) {
    ctx.state.logger.error({
      amountInMinor: amountInMinor,
      currency: currency,
      language: language
    }, "Invalid language parameter passed to localizeCurrency");
    language = 'en';
  }

  if (!_.isFinite(digits)) {
    digits = _getDigitsForCurrency(currency);
  }
  let amountInMajor = Decimal(amountInMinor).div(Math.pow(10, digits)).toNumber();

  return new Intl.NumberFormat(language === 'ar' ? 'en' : language, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: digits
  }).format(amountInMajor);
}

function localizeNumber (amount, language) {
  return new Intl.NumberFormat(language === 'ar' ? 'en' : language).format(amount);
}

/*
* @function subtractFromCurrency
*
* Converts incoming subtractFromValue into fromCurrency and subtracts fromCurrencyAmount f
* rom the converted value.
*
* Note: Expects positive numbers, converts negative numbers to positive.
*
* @param {string} fromCurrency - Three letter currency code representing the currency
* to be converted from.
* @param {string} toCurrency - The desired end currency to return for the remaining
* property.
* @param {number} fromCurrencyAmount - The amount to be subtracted from the converted
* value.
* @param {number} subtractFromValue - The original value to convert and subtract from
* expressed in toCurrency value.
*
* @returns object with following properties:
*     remaining: The remaining value in toCurrency
*     subtracted: The value that was subtracted from the converted subtractFromValue
*     incomingAs: The value that was converted for subtraction
*     convertedIncoming: The converted value that was used for subtraction
*/
function * subtractFromCurrency(fromCurrency, toCurrency, fromCurrencyAmount, subtractFromValue, ctx) {
  if (!_.isString(fromCurrency) || fromCurrency.length !== 3 || !_.isString(toCurrency) || toCurrency.length !== 3) {
    ctx.throw(400, {fromCurrency: fromCurrency, toCurrency: toCurrency}, "Invalid currency parameters for subtractFromCurrency");
  }

  let result, sub, convertedsubtractFromValue;
  let toSubtract = Math.abs(fromCurrencyAmount);
  convertedsubtractFromValue = yield convertCurrency(subtractFromValue, toCurrency, fromCurrency, ctx);
  if (toSubtract > convertedsubtractFromValue) {
    sub = toSubtract - (toSubtract - convertedsubtractFromValue);
    result = yield convertCurrency(convertedsubtractFromValue - sub, fromCurrency, toCurrency, ctx);
  } else {
    sub = toSubtract;
    result = yield convertCurrency(convertedsubtractFromValue - toSubtract, fromCurrency, toCurrency, ctx);
  }
  return {remaining: result, subtracted: sub, incomingAs: subtractFromValue, convertedIncoming: convertedsubtractFromValue};
}

function _getDigitsForCurrency (currency) {
  if (!_.isString(currency) || currency.length !== 3) return 2;
  if (currency.toLowerCase() === 'btc' || currency.toLowerCase() === 'xbt') {
    return 8; // Bitcoin has 8 digits. (not defined in iso 4217 like other currencies)
  }
  let isoCurrency = currency ? cc.code(currency) : cc.code('usd'); // there's a chance cc.code will return undefined... usd in that case which essentially means we default to a two decimal place system
  let exponent = _.get(isoCurrency, 'digits');
  if (!_.isFinite(exponent)) exponent = 2; // there's also a chance that the currency doesn't have a declared amount of digits... default to 2
  return exponent;
}

/*
 * @function getMajorAmountForCurrency
 *
 * Converts the amountInMinor for the given currency to its corresponding
 * decimal amount.
 *
 * Example: 24 being a amountInMinor for 24 cents in usd would be returned as 0.24
 *
 * @param{Number} amountInMinor - The amount without decimal points.
 * @param{String} currency - The currency to work with.
 *
 * @returns{Number} The amountInMinor converted to its proper decimal format.
 */
function getMajorAmountForCurrency (amountInMinor, currency) {
  let digits = _getDigitsForCurrency(currency);
  return Decimal(amountInMinor).div(Math.pow(10, digits)).toNumber().toFixed(digits);
}

/*
 * @function getMinorAmountForCurrency
 *
 * Converts the amountInMajor for the given currency to its corresponding
 * non-decimal amount.
 *
 * Example: 0.24 being a amountInMajor for 24 cents in usd would be returned as 24
 *
 * @param{Number} amountInMajor - The amount without decimal points.
 * @param{String} currency - The currency to work with.
 * @param{Boolean} isPayment - Boolean to determine whether rounding needs to go
 *   up(for payments) or down (for withdrawals).
 *
 * @returns{Number} The amountInMajor converted to its proper non-decimal format
 *   rounded up or down depending on whether it is a payment or not.
 */
function getMinorAmountForCurrency (amountInMajor, currency, isPayment) {
  let amountInMinor = Decimal(amountInMajor).mul(Math.pow(10, _getDigitsForCurrency(currency))).toNumber();
  if (isPayment) {
    return Math.ceil(amountInMinor);
  } else {
    return Math.floor(amountInMinor);
  }
}

/*
 * @function getMinorAmountForTransactionCurrency
 *
 * Converts the amountInMajor for the given currency to its corresponding
 * non-decimal amount. This is specifically used by the lambda-transaction repo for converting
 * the amounts in both negative and non-negative types.
 *
 * Example: 0.24 being a amountInMajor for 24 cents in usd would be returned as 24
 *
 * @param{Number} amountInMajor - The amount without decimal points.
 * @param{String} currency - The currency to work with.
 * @param{Boolean} isPayment - Boolean to determine whether rounding needs to go
 *   up(for payments) or down (for withdrawals).
 *
 * @returns{Number} The amountInMajor converted to its proper non-decimal format
 *   rounded up or down depending on whether it is a payment or not.
 */
function getMinorAmountForTransactionCurrency (amountInMajor, currency, isPayment) {
  let amountInMinor = Decimal(amountInMajor).mul(Math.pow(10, _getDigitsForCurrency(currency))).toNumber();
  if (isPayment) {
    return Math.ceil(amountInMinor);
  } else {
    return Math.ceil(amountInMinor);
  }
}

/*
 * @function convertCurrency
 *
 * Converts the incoming amount to the to currency after obtaining the exchange rate. Rounds
 * down to nearest whole number. This is to be used for withdrawals to ensure no money is lost.
 *
 * @param{Number} amount - The amount in minor units to be converted (e.g. cents not dollars)
 * @param{String} from - The currency to convert from, ISO 4217 code
 * @param{String} to - The currency to convert to, ISO 4217 code
 * @param{String} reqId - Unique request identifier
 * @param{String} sessionId - Unique request identifier
 *
 * @returns{Number} The amount in minor units converted to the @param to currency.
 */
function * convertCurrency (amountInMinor, from, to, ctx) {
  if (!_.isFinite(amountInMinor) || !_.isString(from) || from.length !== 3 || !_.isString(to) || to.length !== 3) {
    ctx.throw(400, {amountInMinor: amountInMinor, from: from, to: to}, "Invalid parameters passed to convert currency");
  }
  if (from === to || amountInMinor === 0) {
    return amountInMinor;
  }
  let rate = yield clients.getCurrencyClient().getCurrencyConversionRate(from, to, ctx);
  let fromInMajor = getMajorAmountForCurrency(amountInMinor, from);
  let toInMajor = Decimal(fromInMajor).mul(rate).toNumber();
  // TODO Return the rate used for the conversion in addition to the converted rate.
  return getMinorAmountForCurrency(toInMajor, to, false);
}

/*
 * @function convertCurrency
 *
 * Converts the incoming amount to the to currency after obtaining the exchange rate. Rounds
 * up to nearest whole number. This is to be used for purchases to ensure no money is lost.
 *
 * @param{Number} amount - The amount in minor units to be converted (e.g. cents not dollars)
 * @param{String} from - The currency to convert from, ISO 4217 code
 * @param{String} to - The currency to convert to, ISO 4217 code
 * @param{String} reqId - Unique request identifier
 * @param{String} sessionId - Unique request identifier
 *
 * @returns{Number} The amount in minor units converted to the @param to currency.
 */
function * convertCurrencyForPayment (amountInMinor, from, to, ctx) {
  if (!_.isFinite(amountInMinor) || !_.isString(from) || from.length !== 3 || !_.isString(to) || to.length !== 3) {
    ctx.throw(400, {amountInMinor: amountInMinor, from: from, to: to}, "Invalid parameters passed to convert currency for payment");
  }
  if (from === to || amountInMinor === 0) {
    return amountInMinor;
  }
  let rate = yield clients.getCurrencyClient().getCurrencyConversionRate(from, to, ctx);
  let fromInMajor = getMajorAmountForCurrency(amountInMinor, from);
  let toInMajor = Decimal(fromInMajor).mul(rate).toNumber();
  return getMinorAmountForCurrency(toInMajor, to, true);
}

function * getMinorAmountForPackage (purchaseType, currency, ctx) {
  ctx.assert(configs.purchaseItems[purchaseType], 400, 'Purchase item does not exist', {
    configPurchaseItems: configs.purchaseItems,
    currency: currency,
    purchaseType: purchaseType
  });
  let amountInDollars = getMinorAmountForCurrency(configs.purchaseItems[purchaseType].dollarAmount, 'usd', true);

  if (currency.toLowerCase() !== 'usd') {
    return yield convertCurrencyForPayment(amountInDollars, 'usd', currency, ctx);
  } else {
    return amountInDollars;
  }
}

function aggregateUniqueCurrenciesForTransactions (transactions) {
  var balances = {};

  for (var transaction of transactions) {
    let key = transaction.state === 'paid' ? 'available' : 'pending';
    let currency = transaction.currency.toLowerCase();

    balances[currency] = balances[currency] || {};
    balances[currency][key] = balances[currency][key] || 0;
    balances[currency][key] += transaction.amount_to_user;
  }

  return balances;
}

function * convertCurrencies (balances, toCurrency, ctx) {
  let convertedBalance = {
    pending: 0,
    available: 0,
    escrowed: 0,
    total: 0
  };

  var toFetch = {
    pending: [],
    available: [],
    escrowed: []
  };
  _.each(['pending', 'available', 'escrowed'], key => {
    _.each(balances, (balance, currency) => {
      var amount = balance[key] || 0;
      if(currency.toLowerCase() === toCurrency.toLowerCase()){
        convertedBalance[key] += amount;
      }else if(amount){
        toFetch[key].push({from: currency, to: toCurrency, amount: getMajorAmountForCurrency(amount)});
      }
    });
  });

  var client = clients.getCurrencyClient();


  if(toFetch.pending.length > 0){
    convertedBalance.pending += getMinorAmountForCurrency(_.sum(yield client.convertCurrencies(toFetch.pending, ctx), 'amount'), toCurrency);
  }
  if(toFetch.available.length > 0){
    convertedBalance.available += getMinorAmountForCurrency(_.sum(yield client.convertCurrencies(toFetch.available, ctx), 'amount'), toCurrency);
  }

  convertedBalance.total = convertedBalance.pending + convertedBalance.available;
  return convertedBalance;
}

function init (_configs) {
  configs = _configs;
  clients.init(_configs);
}

if (global.configs) {
  init(global.configs);
}

module.exports = {
  convertCurrency: convertCurrency,
  convertCurrencyForPayment: convertCurrencyForPayment,
  localizeCurrency: localizeCurrency,
  localizeNumber: localizeNumber,
  getDecimalAmountForCurrency: getMajorAmountForCurrency,
  getIntegerAmountForCurrency: getMinorAmountForCurrency,
  getMinorAmountForTransactionCurrency: getMinorAmountForTransactionCurrency,
  getMinorAmountForPackage: getMinorAmountForPackage,
  aggregateUniqueCurrenciesForTransactions: aggregateUniqueCurrenciesForTransactions,
  convertCurrencies: convertCurrencies,
  subtractFromCurrency: subtractFromCurrency,
  init: init
};
