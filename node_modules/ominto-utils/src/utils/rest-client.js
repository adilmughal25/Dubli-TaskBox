'use strict';

const assert = require('http-assert');
const qs = require('./url').toQueryString;
const requestDispatcher = require('request-promise');
const _ = require('lodash');
const uuid = require('node-uuid');

module.exports = newRestClient;

function newRestClient (config, isDefaultSimple, boundContext) {
  const base = {
    baseUrl: config.internalUrl || config.url,
    simple: false,
    resolveWithFullResponse: true,
    json: true
  };
  if (isDefaultSimple) {
    base.simple = true;
  }

  const isNot4xxOr5xx = function (status) {
    return status < 400 || status === 404;
  };

  const pathJoin = function (path) {
    return _.isArray(path) ? path.join('/') : path;
  };

  const checkResponse = function (ctx, resp, reqInfo) {
    const wasSuccessful = isNot4xxOr5xx(resp.statusCode);
    const errorMessage = _.get(resp, 'body.message') || resp.body;
    assert(wasSuccessful, resp.statusCode, errorMessage, {reqInfo: reqInfo, internalCode: 351, res: resp, code: _.get(resp, 'body.code') || resp.body});
  };

  let simple = false;
  const execute = function * (request, ctx) {
    const req = _.extend({}, base, request);
    req.auth = _.result(config, 'auth');
    if (simple) {
      req.simple = true;
    }

    // request-promise converts arrays into a[0]=1&a[1]=2 by default. Other options are simple repeat (a=1&a=2) or
    // brackets (a[]=1&a[]=2). Neither are what we want, so replace the qs argument with a querystring in the url.
    if (req.qs) {
      req.url += qs(req.qs, true);
      delete req.qs;
    }

    const logger = _.get(ctx, 'state.logger') || _.get(ctx, 'logger');
    if (ctx && logger && logger.fields) {
      _.set(req, 'headers.X-Request-Id', _((logger.fields.req_id || '').match(/[^,\s]+/g) || []).push(uuid.v4()).join(', '));
      _.set(req, 'headers.X-Session-Id', logger.fields.session_id || uuid.v4());
    }

    simple = false;
    let result = yield requestDispatcher(req);
    // retry 504 once once due to data elb insta-returning a 504 every once in a while
    if (request.method === 'GET' && result.statusCode === 504) {
      logger.warn({res: result}, "504 received from Data");
      result = yield requestDispatcher(req);
    }
    return req.simple ? result.body : result;
  };

  return {
    /**
     * Toggles simple mode (fail promise on non-2xx). Resets after each request
     *
     * @returns {Object} - the client itself for chaining
     */
    simple: function () {
      return newRestClient(config, true, boundContext);
    },

    /**
     * Bind a context for all requests. Makes calling each request slightly easier.
     *
     * @param {Object} context - Used to find request and session ids at either 'state.logger.fields' or 'logger.fields' paths
     * @returns {{simple: self.simple, bind: self.bind, get, delete, post, put, patch}}
     */
    bind: function (context) {
      return newRestClient(config, isDefaultSimple, context);
    },

    /**
     *
     * @returns {Object|String|Number|null} - the result of a successful request
     * @throws HTTP error on non-200 response
     */
    get: requestWithQuery('get'),
    delete: requestWithQuery('delete'),
    del: requestWithQuery('delete'), // For compatibility with Node's request and request-promise

    post: requestWithBody('post'),
    put: requestWithBody('put'),
    patch: requestWithBody('patch')
  };

  /**
   * Returns a function for making a request that contains a query string (GET and DELETE)
   *
   * @param {String} method - the HTTP method that should be used.
   * @returns {Function}
   */
  function requestWithQuery (method) {
    return function * (path, query, context) {
      let ctx;
      if (_.has(query, 'state.logger') || _.has(query, 'logger')) {
        ctx = query;
        query = null;
      } else {
        ctx = context || boundContext;
      }
      const result = yield execute({
        method: method.toUpperCase(),
        url: pathJoin(path),
        qs: query
      }, ctx);
      if (result && result.statusCode) {
        checkResponse(ctx, result, {
          path: path,
          query: query
        });
        return _.pick(result, ['statusCode', 'body', 'headers', 'cookies', 'request']);
      } else {
        // Simple mode, it won't get here if there was an error
        return result;
      }
    };
  }

  function requestWithBody (method) {
    return function * (path, body, bodyType, context) {
      let ctx, content;
      if (_.isString(bodyType)) {
        ctx = context || boundContext;
        content = bodyType;
      } else if (_.has(body, 'state.logger') || _.has(body, 'logger')) {
        ctx = body;
      } else {
        ctx = bodyType || boundContext;
      }
      const req = {
        method: method.toUpperCase(),
        url: pathJoin(path)
      };
      if (content) {
        req[content] = body;
      } else {
        req.body = body;
      }
      const result = yield execute(req, method, ctx);
      if (result && result.statusCode) {
        checkResponse(ctx, result, {
          path: path,
          body: body
        });
        return _.pick(result, ['statusCode', 'body', 'headers', 'cookies', 'request']);
      } else {
        // Simple mode, it won't get here if there was an error
        return result;
      }
    };
  }
}
