/*eslint-disable no-console */
'use strict';

var _ = require('lodash');
var co = require('co');
var denodeify = require('denodeify');
var zlib = require('zlib');
var EventEmitter = require('events').EventEmitter;
var gunzip = denodeify(zlib.gunzip);
var uuid = require('node-uuid');
var _check = require('./check-api-response');
var serializers = require('./custom-serializers');
var reqAndSession = require('./req-and-session');
var clients = require('../clients/clients');
var createError = require('http-errors');
var assert = require('http-assert');
var log = require('./log');
var firehoseLog = require('./firehose-logger');

var configs;

function checkConfigs (o_configs) {
  if (!o_configs.data_api || typeof o_configs.data_api !== 'object' || !o_configs.data_api.url || !o_configs.data_api.auth) {
    throw new Error('kinesis handler: configs.data_apis misconfigured :(');
  }
}

function getClient (o_configs) {
  var url = o_configs.data_api.url;
  var auth = o_configs.data_api.auth;
  var getDataClient = require('../utils').getDataClient;
  return getDataClient(url, auth);
}

function response () {
  return {
    failures: 0,
    successes: 0,
    misses: 0,
    errors: []
  };
}

function _logError (logger, err) {
  logger.error({
    err: err
  }, 'Lambda handler failed');
}

var parsePayload = co.wrap(function *(s_data, o_ctx) {
  var s_payload = new Buffer(s_data, 'base64').toString('utf8');
  var o_payload = JSON.parse(s_payload);
  // if (_.get(o_payload, 'flags.gzipped_data') === true) {
  if (o_payload.data.gzippedData) {
    var compressed = new Buffer(o_payload.data.gzippedData, 'base64');
    var uncompressed = yield gunzip(compressed);
    o_payload.data = JSON.parse(uncompressed);
  } else if (o_payload.data.redisDataKey) {
    // JSON.parse will happen on the data service side here
    o_payload.data = (yield o_ctx.dataService.get('/getKinesisRedisData/' + o_payload.data.redisDataKey).then(_check('cant lookup payload from kinesis'))).body;
  }
  return o_payload;
});

function makeEmitFn (emitter, s_type, o_payload) {
  return function (eventName) {
    var args = [].slice.call(arguments, 1);
    args.unshift(eventName, s_type);
    args.push(o_payload);
    emitter.emit.apply(emitter, args);
  };
}

function getLogger (s_lambdaFunctionName, s_eventType, o_payload, requestId, invocationId, sequenceNumber) {
  var fields = {
    name: 'lambda:' + s_eventType,
    functionName: s_lambdaFunctionName,
    req_id: reqAndSession.getReqIdFromTrigger(o_payload.trigger),
    session_id: reqAndSession.getSessionIdFromTrigger(o_payload.trigger),
    serializers: {
      err: serializers.err
    },

    // this key is so you can easily search aws logs for all of the
    // log entries related to a single invocation of a lambda handler.
    // a single aws request can contain multiple event records to process,
    // so we attach both to the logger:
    awsRequestId: requestId,
    invocationId: invocationId,
    sequenceNumber: sequenceNumber
  };
  ['trigger', 'timestamp', 'jwt', 'flags'].forEach(function (field) {
    if (o_payload[field]) fields['kinesis_' + field] = o_payload.field;
  });
  return log.createLogger("lambda_" + s_lambdaFunctionName, fields.name, configs, fields);
}

var processEvents = co.wrap(function *(event, emitter, impls, fields, context) {
  var ret = response();

  function _err (e) {
    if (e) ret.errors.push(e.stack ? e.stack : e.toString());
  }

  function fail (e) {
    _err(e);
    ret.failures++;
  }

  function success () {
    ret.successes++;
  }

  function miss (s_msg) {
    _err(s_msg);
    ret.misses++;
  }

  var requestId = context.awsRequestId;
  var records = event.Records;
  var proc = co.wrap(function *(o_rec) {
    try {
      let invocationId = uuid.v4();
      var sequenceNumber = o_rec.kinesis.sequenceNumber;
      var o_payload = yield parsePayload(o_rec.kinesis.data, fields);
      console.log(JSON.stringify(o_payload));
      var s_type = o_payload.type;
      var handler = impls[s_type];
      if (!handler) {
        const regexPrefix = /^regex:/;
        const matchingKey = _(impls).pick((v, k) => regexPrefix.test(k)).findKey((v, k) => new RegExp(k.replace(/^regex:/, '')).test(s_type));
        if (matchingKey) {
          handler = impls[matchingKey];
        }
      }

      if (!handler) {
        return miss('handler not found for ' + s_type);
      }

      var _emit = makeEmitFn(emitter, s_type, o_payload);
      var logger = getLogger(context.functionName, s_type, o_payload, requestId, invocationId, sequenceNumber);
      logger.info({
        payload: o_payload
      }, 'Lambda handler invoked');
      var ctx = _.extend({}, fields, {
        payload: o_payload,
        emit: _emit,
        logger: logger,
        state: {
          logger: logger,
          jwt: o_payload.jwt
        }, // TODO: this is for compatibility with client reqs written for koa -- can refactor later
        throw: function () {
          throw createError.apply(null, arguments);
        },
        assert: assert,
        awsRequestId: requestId,
        invocationId: invocationId,
        sequenceNumber: sequenceNumber
      });
      var bound = handler.bind(ctx);
      _emit('handler-start');
      var startTime = Date.now();
      yield co(bound)
        .then(res => {
          var endTime = Date.now();
          var invocationTime = endTime - startTime + 'ms';
          _emit('handler-success', res);
          var report = {
            invocationTime: invocationTime
          };
          if (res) report.result = res;
          logger.info({report: report}, 'Lambda handler succeeded');
          success();
        })
        .catch(err => {
          _logError(logger, err);
          _emit('handler-error', err);
          fail(err);
        });
    } catch (e) {
      fail(e);
    }
  });
  yield records.map(proc);
  return ret;
});

function lambdaHandler (o_configs, impls, extraFields) {
  checkConfigs(o_configs);
  configs = o_configs; //Hacky
  var _dataClient = getClient(o_configs);
  clients.init(o_configs);
  var fields = _.extend({}, extraFields, {
    dataService: _dataClient,
    configs: o_configs,
    utils: require('../utils'),
    clients: clients
  });
  var emitter = handler.events = new EventEmitter();
  return handler;

  function handler (event, context) {
    processEvents(event, emitter, impls, fields, context)
      .then(result => {
        firehoseLog.flush().then(() => {
          context.done(null, JSON.stringify(result, null, 2));
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(null, JSON.stringify(result, null, 2));
        });
      })
      .catch(error => {
        console.log(JSON.stringify(error));
        firehoseLog.flush().then(() => {
          context.done(error);
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(error);
        });
      });
  }
}

function checkMatch (def, patternKey, against) {
  const pattern = def[patternKey];
  if (!def[patternKey]) return true;

  if (_.isString(pattern)) {
    if (against.indexOf(pattern) !== 0) return false;
  } else if (_.isRegExp(pattern)) {
    if (!pattern.test(against)) return false;
  } else {
    throw new Error(patternKey + ' must be a string or regexp, is ' +
      typeof pattern + ':' + pattern + ' in ' + JSON.stringify(def));
  }
  return true;
}

function checkS3Handler (def, o_record) {
  if (!def.operation && !def.path && !def.bucket && def.spec && _.isArray(def.spec) && def.spec.length === 3) {
    def.operation = def.spec[0];
    def.bucket = def.spec[1];
    def.path = def.spec[2];
  }

  if (!checkMatch(def, 'path', o_record.s3.object.key)) return false;
  if (!checkMatch(def, 'bucket', o_record.s3.bucket.name)) return false;
  if (!checkMatch(def, 'operation', o_record.eventName)) return false;
  return true;
}

var processEventsS3 = co.wrap(function *(event, emitter, handlers, fields, context) {
  var ret = response();

  function _err (e) {
    if (e) ret.errors.push(e.stack ? e.stack : e.toString());
  }

  function fail (e) {
    _err(e);
    ret.failures++;
  }

  function success () {
    ret.successes++;
  }

  function miss (s_msg) {
    _err(s_msg);
    ret.misses++;
  }

  var requestId = context.awsRequestId;
  var records = event.Records;
  var proc = co.wrap(function *(o_record) {
    try {
      let invocationId = uuid.v4();
      let filePath = o_record.s3.object.key;
      let fileBucket = o_record.s3.bucket.name;
      let fileOperation = o_record.eventName;
      let fileDescription = fileOperation + ' in bucket ' + fileBucket + ' at path ' + filePath;
      let s_type = [fileOperation, fileBucket, filePath].join(':');
      let handler;
      for (let i = 0; i < handlers.length; i++) {
        let result = checkS3Handler(handlers[i], o_record);
        if (result) {
          handler = handlers[i];
          break;
        }
      }
      if (!handler) return miss('handler not found for ' + fileDescription);

      let o_payload = o_record.s3;
      console.log(JSON.stringify(o_payload));
      o_payload.operation = o_record.eventName;

      var _emit = makeEmitFn(emitter, s_type, o_payload);
      var logger = getLogger(context.functionName, s_type, o_payload, requestId, invocationId, 0);
      logger.info({
        payload: o_payload
      }, 'Lambda handler invoked');
      var ctx = _.extend({}, fields, {
        envelope: _.omit(o_record, 's3'),
        payload: o_payload,
        emit: _emit,
        logger: logger,
        state: {
          logger: logger,
          jwt: o_payload.jwt
        }, // TODO: this is for compatibility with client reqs written for koa -- can refactor later
        throw: function () {
          throw createError.apply(null, arguments);
        },
        assert: assert,
        awsRequestId: requestId,
        invocationId: invocationId
      });

      var bound = handler.handler.bind(ctx);
      _emit('handler-start');
      var startTime = Date.now();
      yield co(bound)
        .then(res => {
          var endTime = Date.now();
          var invocationTime = endTime - startTime + 'ms';
          _emit('handler-success', res);
          var report = {
            invocationTime: invocationTime
          };
          if (res) report.result = res;
          logger.info({report: report}, 'Lambda handler succeeded');
          success();
        })
        .catch(err => {
          _logError(logger, err);
          _emit('handler-error', err);
          fail(err);
        });
    } catch (e) {
      fail(e);
    }
  });
  yield records.map(proc);
  return ret;
});

function lambdaHandlerS3 (o_configs, handlers, extraFields) {
  checkConfigs(o_configs);
  configs = o_configs; //Hacky
  var _dataClient = getClient(o_configs);
  clients.init(o_configs);
  var fields = _.extend({}, extraFields, {
    dataService: _dataClient,
    configs: o_configs,
    utils: require('../utils'),
    clients: clients
  });
  var emitter = handler.events = new EventEmitter();
  return handler;

  function handler (event, context) {
    processEventsS3(event, emitter, handlers, fields, context)
      .then(result => {
        firehoseLog.flush().then(() => {
          context.done(null, JSON.stringify(result, null, 2));
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(null, JSON.stringify(result, null, 2));
        });
      })
      .catch(error => {
        console.log(JSON.stringify(error));
        firehoseLog.flush().then(() => {
          context.done(error);
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(error);
        });
      });
  }
}

function lambdaHandlerSNS (o_configs, handlers, extraFields) {
  checkConfigs(o_configs);
  configs = o_configs; //Hacky
  var _dataClient = getClient(o_configs);
  clients.init(o_configs);
  var fields = _.extend({}, extraFields, {
    dataService: _dataClient,
    configs: o_configs,
    utils: require('../utils'),
    clients: clients
  });
  var emitter = handler.events = new EventEmitter();
  return handler;

  function handler (event, context) {
    processEventsSNS(event, emitter, handlers, fields, context)
      .then(result => {
        firehoseLog.flush().then(() => {
          context.done(null, JSON.stringify(result, null, 2));
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(null, JSON.stringify(result, null, 2));
        });
      })
      .catch(error => {
        console.log(JSON.stringify(error));
        firehoseLog.flush().then(() => {
          context.done(error);
        }).catch(flushErr => {
          console.log('firehose error: ' + JSON.stringify(flushErr));
          context.done(error);
        });
      });
  }
}

var processEventsSNS = co.wrap(function *(event, emitter, handlers, fields, context) {
  var ret = response();

  function _err (e) {
    if (e) ret.errors.push(e.stack ? e.stack : e.toString());
  }

  function fail (e) {
    _err(e);
    ret.failures++;
  }

  function success () {
    ret.successes++;
  }

  function miss (msg) {
    _err(msg);
    ret.misses++;
  }

  var requestId = context.awsRequestId;
  var records = event.Records;
  var proc = co.wrap(function *(record) {
    try {
      let invocationId = uuid.v4();
      let payload = record.Sns;
      console.log(JSON.stringify(payload));
      let type = payload.TopicArn;
      if (!handlers[type]) return miss('handler not found for ARN' + type);

      var _emit = makeEmitFn(emitter, type, payload);
      var logger = getLogger(context.functionName, type, payload, requestId, invocationId, 0);
      logger.info({
        payload: payload
      }, 'Lambda handler invoked');
      var ctx = _.extend({}, fields, {
        envelope: _.omit(record, 'Sns'),
        payload: payload,
        emit: _emit,
        logger: logger,
        state: {
          logger: logger,
          jwt: payload.jwt
        }, // TODO: this is for compatibility with client reqs written for koa -- can refactor later
        throw: function () {
          throw createError.apply(null, arguments);
        },
        assert: assert,
        awsRequestId: requestId,
        invocationId: invocationId
      });

      var bound = handlers[type].bind(ctx);
      _emit('handler-start');
      var startTime = Date.now();

      yield co(bound)
        .then(res => {
          var endTime = Date.now();
          var invocationTime = endTime - startTime + 'ms';
          _emit('handler-success', res);
          var report = {
            invocationTime: invocationTime
          };
          if (res) report.result = res;
          logger.info({report: report}, 'Lambda handler succeeded');
          success();
        })
        .catch(err => {
          _logError(logger, err);
          _emit('handler-error', err);
          fail(err);
        });
    } catch (e) {
      fail(e);
    }
  });
  yield records.map(proc);
  return ret;
});

module.exports = {
  handler: lambdaHandler,
  s3handler: lambdaHandlerS3,
  lambdaHandlerSNS: lambdaHandlerSNS,

  // for testing
  processEvents: processEvents,
  makeEmitFn: makeEmitFn,
  parsePayload: parsePayload,
  response: response,
  checkConfigs: checkConfigs,
  getClient: getClient
};
