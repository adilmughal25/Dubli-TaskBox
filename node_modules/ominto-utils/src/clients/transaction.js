'use strict';

const helpers = require('./helpers');
const _ = require('lodash');
const toQueryString = require('../utils/url').toQueryString;
const currency = require('../utils/currency');
const clients = require('./clients');
const getTimestamp = date => Date.parse(date) ? new Date(Date.parse(date)).toISOString() : date;
const TYPE = {
  master: 'master_withdrawal',
  detail: 'withdrawal_detail'
};
let dataClient;

function * createTransaction (transactionFields, ctx) {
  let result = yield dataClient.post(helpers.setRequestPayload('/createTransaction/', ctx, transactionFields));

  // check for duplicate unique key
  // TODO: update data contract -- something cleaner than SQL messages coming back from data
  if (result.body && result.body.code === 'ER_DUP_ENTRY') {
    ctx.throw(400, 'Unique field already in use', {
      internalCode: 52,
      duplicateKey: true
    });
  }
  ctx.assert(result.statusCode === 201, 500, 'Unexpected result from data service during createTransaction', {
    res: result,
    transactionFields: transactionFields,
    internalCode: 351
  });
  return result.body;
}

/*
 * @function createTransactionsForWithdrawal
 *
 * Handles the creation and association of master_withdrawals and its withdrawal_details. Creates the master withdrawal
 * and then creates the withdrawal_details using the master withdrawals id. Throws appropriate status code errors if
 * checks fail.
 *
 * @param {Object} masterWithdrawal - The master withdrawal to create.
 * @params {Array | Object} withdrawalDetails - The details to associate to the master withdrawal.
 * @param {Object} ctx - Context object containing logger and error handling functionality.
 *
 * @returns {Array} all transactions associated with this withdrawal.
 */
function * createTransactionsForWithdrawal (masterWithdrawal, withdrawalDetails, ctx) {
  let results = [];
  let masterWithdrawalDetails = yield dataClient.post(helpers.setRequestPayload('/createTransaction/', ctx,
    masterWithdrawal));

  // check for duplicate unique key
  // TODO: update data contract -- something cleaner than SQL messages coming back from data
  if (masterWithdrawalDetails.body && masterWithdrawalDetails.body.code === 'ER_DUP_ENTRY') {
    ctx.throw(400, 'Unique field already in use', {
      internalCode: 52,
      duplicateKey: true
    });
  }
  ctx.assert(masterWithdrawalDetails.statusCode === 201, 500, 'Unexpected result from data service during' +
    ' createTransaction', {
    res: masterWithdrawalDetails,
    transactionFields: masterWithdrawal,
    internalCode: 351
  });

  results.push(masterWithdrawalDetails.body);
  let updatedDetails = yield setSourceTransactionForWithdrawalDetails(masterWithdrawalDetails.body.id,
    withdrawalDetails);
  let withdrawalDetailsResult = yield createWithdrawalDetailTransactions(updatedDetails, ctx);
  return _.union(results, withdrawalDetailsResult);
}

/*
* @function createWithdrawalDetailTransactions
*
* Iterates over the withdrawal details passed in and creates a transaction for each one. Returning an array of
* the created transactions.
*
* @param {array | object} withdrawalDetails - The withdrawal_details to create transactions for.
* @param {object} ctx - The context object used for error handling and logging here.
*
* @returns {array} array of created withdrawal_detail transactions.
*/
function * createWithdrawalDetailTransactions (withdrawalDetails, ctx) {
  let results = [];
  for (let i = 0, len = withdrawalDetails.length; i < len; i++) {
    let withdrawalDetailsResult = yield dataClient.post(helpers.setRequestPayload('/createTransactions/', ctx,
      withdrawalDetails[i]));
    if (withdrawalDetailsResult.body && withdrawalDetailsResult.body.code === 'ER_DUP_ENTRY') {
      ctx.throw(400, 'Unique field already in use', {
        internalCode: 52,
        duplicateKey: true
      });
    }
    ctx.assert(withdrawalDetailsResult.statusCode === 201, 500, 'Unexpected result from data service during' +
      ' createTransaction', {
      res: withdrawalDetailsResult,
      transactionFields: withdrawalDetails[i],
      internalCode: 351
    });
    results.push(withdrawalDetailsResult.body);
  }
  return results;
}

function * reassignTrasnactions (from, to, ctx) {
  let result = yield dataClient.post(helpers.setRequestPayload('/reassignTransactions', ctx, {
    from: from,
    to: to
  }));

  ctx.assert(result.statusCode === 200, 500, 'Server error when reassigning transactions', {
    res: result,
    req: {
      from: from,
      to: to
    }
  });

  return result.body;
}

function * patchTransaction (transactionId, transactionFields, ctx) {
  let result = yield dataClient.patch(helpers.setRequestPayload('/patchTransaction/' + transactionId + '/', ctx, transactionFields));

  // TODO: update data contract -- something cleaner than SQL messages coming back from data
  if (result.body && result.body.code === 'ER_DUP_ENTRY') {
    ctx.throw(400, 'Unique field already in use', {
      internalCode: 52,
      duplicateKey: true
    });
  }
  ctx.assert(result.statusCode === 204, 500, 'Unexpected result from data service during patchTransaction', {
    res: result,
    transactionId: transactionId,
    transactionFields: transactionFields,
    internalCode: 351
  });
  return result.body;
}

function * getTransactionById (transactionId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getTransactionById/' + transactionId + '/', ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getTransactionById', {
    res: result,
    transactionId: transactionId,
    internalCode: 351
  });
  return result.body;
}

function * getTransactionBySourceTransactionId (sourceTransactionId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getTransactionBySourceTransactionId/' + sourceTransactionId + '/', ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getTransactionBySourceTransactionId', {
    res: result,
    sourceTransactionId: sourceTransactionId,
    internalCode: 351
  });
  return result.body;
}

function * getTransactionByIdForUser (transactionId, userId, ctx) {
  var transaction = yield getTransactionById(transactionId, ctx);
  ctx.assert(transaction.user_id === userId, 404, 'Transaction not found', {
    internalCode: 160
  });
  return transaction;
}

function * getAllTransactionIdsForUser (userId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getTransactionIdsForUser/' + userId + '/', ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getAllTransactionIdsForUser', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}

function * getAllTransactionsForUser (userId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getTransactionsForUser/' + userId + '/' + '?bypass=true', ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getAllTransactionsForUser', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}

function * searchUserTransactions (userId, params, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/searchTransactionsForUser/' + userId + '/' + toQueryString(params), ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during searchUserTransactions', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}



function * searchBspTransactions (params, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/searchBspTransactions/' + toQueryString(params), ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during searchBspTransactions', {
    res: result,
    internalCode: 351
  });
  return result.body;
}

function * getUserFromSourceTxnId (sourceId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getUserFromSourceTxnId/' + sourceId + '/', ctx));
  ctx.assert(result.statusCode !== 404, 404, 'User not found', {
    internalCode: 111
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getUserFromSourceTxnId', {
    res: result,
    sourceId: sourceId,
    internalCode: 351
  });
  return result.body;
}

/*
 * @function lockWithdrawal
 *
 * Sets a key in redis used to temporarily lock the api withdrawal route so that a user cannot spam it.
 *
 * @param{string} userId - The id of the user to be used for part of the key in redis.
 * @param{object} ctx - The context to use to properly fail and log if the lock fails.
 *
 * @returns{object | boolean} True if lock is successful, throws an http 400 response if lock cannot be obtained.
 */
function * lockWithdrawal (userId, ctx) {
  let result = yield dataClient.post(helpers.setRequestPayload('/lockWithdrawal/' + userId + '/', ctx));
  ctx.assert(result.statusCode === 201, 400, 'Withdrawals already locked, cannot obtain lock', {
    res: result,
    userId: userId,
    internalCode: 376
  });
  return true;
}

/*
 * @function unlockWithdrawal
 *
 * Deletes the lock key in redis to make withdrawals available again in the withdrawal route in api.
 *
 * @param{string} userId - The id of the user to be used for part of the key in redis.
 * @param{object} ctx - The context to use to properly fail and log if the lock fails.
 *
 * @returns{object | boolean} True if lock is successful, throws an http 400 response if lock cannot be obtained.
 */
function * unlockWithdrawal (userId, ctx) {
  let result = yield dataClient.del(helpers.setRequestPayload('/unlockWithdrawal/' + userId + '/', ctx));
  ctx.assert(result.statusCode === 200, 400, 'Unable to unlock withdrawal', {
    res: result,
    userId: userId,
    internalCode: 377
  });
  return true;
}

/*
 * @function createWithdrawalRequestBody
 *
 * Creates a valid transaction object to send to data.
 *
 * @param{string} userId - The id of the user associated with this withdrawal.
 * @param{string} gateway - The gateway being used for this withdrawal.
 * @param{string} sourceId - The gateways id for this withdrawal in their system.
 * @param{string} currency - The currency for this withdrawal.
 * @param{string} fees - The fees charged by gateway for this withdrawal.
 * @param{string} sourceType - The source type of this withdrawal[bank, credit card, bitcoin etc]
 * @param{string} type - The type of this transaction[master_withdrawal, withdrawal_details]
 * @param{string} amountToUser - The amount going to the user, is negative for withdrawals.
 * @param{string} state - The state for this transaction[ paid, initiated, cancelled]
 *
 * @returns{object} A valid transaction object.
 */
function * createWithdrawalRequestBody (userId, gateway, sourceId, currency, fees, sourceType, type,
  amountToUser, state) {
  let transaction = {
    source_transaction_id: sourceId,
    currency: currency,
    state: state,
    date_initiated: getTimestamp(new Date()),
    amount_fees: fees,
    user_id: userId,
    gateway: gateway,
    type: type,
    direction: 'out',
    source_type: sourceType,
    amount_to_user: amountToUser * -1
  };
  transaction['date_' + state] = getTimestamp(new Date());
  return transaction;
}

/*
 * @function determineFromCurrency
 *
 * Ensures a valid currency is used when determining which currencies to pull for withdrawals.
 *
 * @param{object} request - The incoming request body to check fromCurrencies property
 * @param{object} user - The user object to check for set currency
 * @param{string} defaultCurrency - The fallback currency to use if neither of the others are found.
 *
 * @returns{string | array} either a single currency or an array of currencies.
 */
function * determineFromCurrency (request, user, defaultCurrency) {
  if (request.fromCurrencies && !_.isEmpty(request.fromCurrencies)) {
    return request.fromCurrencies;
  } else if (user.currency && !_.isEmpty(user.currency)) {
    return user.currency;
  } else {
    return defaultCurrency;
  }
}

/*
 * @function getAvailableBalanceForWithdrawalForUserByCurrencies
 *
 * Retrieves a users eligible balances for making a withdrawal for the given currencies.
 *
 * @param{string | array} fromCurrencies - Currency or currencies to withdraw from.
 * @param{string} toCurrency - The currency being withdrawn to.
 * @param{string} userId - The userId to check withdrawals for.
 * @param{string} gateway - The gateway being used for the withdrawal.
 * @param{object} ctx - The context object used for handling exceptions and logging
 *
 * @returns{object | array} List of transactions to create for this withdrawal, available balance for this withdrawal.
 */
function * getAvailableBalanceForWithdrawalForUserByCurrencies (fromCurrencies, toCurrency, userId, gateway, ctx) {
  let outgoingTransactions = [];
  let result = yield dataClient.get(helpers.setRequestPayload('/getAvailableBalanceForWithdrawalForUserByCurrencies/' +
    userId + '/',
    ctx, {
      fromCurrencies: fromCurrencies
    }));

  ctx.assert(result.statusCode === 200 && result.body.length > 0, 400, 'No eligible transactions found for this' +
    ' withdrawal', {
    internalCode: 378,
    fromCurrencies: fromCurrencies,
    userId: userId,
    res: result
  });
  for (let i = 0, len = result.body.length; i < len; i++) {
    let conversionRate = yield clients.getCurrencyClient().getCurrencyConversionRate(result.body[i].currency,
      toCurrency, ctx);
    let transaction = yield createWithdrawalRequestBody(userId, gateway, '', result.body[i].currency, 0, gateway,
      TYPE.detail, result.body[i].total, 'paid');
    transaction.conversion_rate = conversionRate;
    outgoingTransactions.push(transaction);
  }
  let balances = yield aggregateAvailableBalance(result.body);
  let convertedBalance = yield currency.convertCurrencies(balances, toCurrency, ctx);

  return {
    transactions: outgoingTransactions,
    available: {
      currency: toCurrency,
      amount: convertedBalance.available
    }
  };
}

/*
 * @function getAvailableBalanceForWithdrawalForUserByCurrencies
 *
 * Retrieves a users eligible balances for making a withdrawal for the given currencies.
 *
 * @param{string | array} fromCurrencies - Currency or currencies to withdraw from.
 * @param{string} toCurrency - The currency being withdrawn to.
 * @param{string} userId - The userId to check withdrawals for.
 * @param{string} gateway - The gateway being used for the withdrawal.
 * @param{object} ctx - The context object used for handling exceptions and logging
 *
 * @returns{object | array} List of transactions to create for this withdrawal, available balance for this withdrawal.
 */
function * getAvailableBalanceForWithdrawalForUserByCurrenciesForOmintoPayment (fromCurrencies, toCurrency, userId, gateway, ctx) {
  let outgoingTransactions = [];
  let result = yield dataClient.get(helpers.setRequestPayload('/getAvailableBalanceForWithdrawalForUserByCurrencies/' +
      userId + '/',
      ctx, {
        fromCurrencies: fromCurrencies
      }));

  ctx.assert(result.statusCode === 200 && result.body.length > 0, 400, 'No eligible transactions found for this' +
      ' withdrawal', {
    internalCode: 378,
    fromCurrencies: fromCurrencies,
    userId: userId,
    res: result
  });
  for (let i = 0, len = result.body.length; i < len; i++) {
    let conversionRate = yield clients.getCurrencyClient().getCurrencyConversionRate(result.body[i].currency,
        toCurrency, ctx);
    let transaction = yield createWithdrawalRequestBody(userId, gateway, '', toCurrency, 0, gateway,
        TYPE.detail, result.body[i].total, 'paid');
    transaction.conversion_rate = conversionRate;
    outgoingTransactions.push(transaction);
  }
  let balances = yield aggregateAvailableBalanceForOmintoPayment(result.body);
  let convertedBalance = yield currency.convertCurrencies(balances, toCurrency, ctx);

  return {
    transactions: outgoingTransactions,
    available: {
      currency: toCurrency,
      amount: convertedBalance.available
    }
  };
}


/*
 * @function aggregateAvailableBalance
 *
 * Converts the result of available withdrawals for currencies into an object usable by the convertCurrencies function.
 *
 * @param{array | object} available - Object containing available balance and currency(ies).
 *
 * @returns {object} balance object with currency and available key.
 */
function * aggregateAvailableBalance (available) {
  let balances = {};
  for (let availableCurrency of available) {
    let key = 'available';
    let currency = availableCurrency.currency.toLowerCase();

    balances[currency] = balances[currency] || {};
    balances[currency][key] = balances[currency][key] || 0;
    balances[currency][key] += availableCurrency.total;
  }
  return balances;
}

/*
 * @function aggregateAvailableBalance
 *
 * Converts the result of available withdrawals for currencies into an object usable by the convertCurrencies function.
 *
 * @param{array | object} available - Object containing available balance and currency(ies).
 *
 * @returns {object} balance object with currency and available key.
 */
function * aggregateAvailableBalanceForOmintoPayment (available) {
  let balances = {};
  for (let availableCurrency of available) {
    let key = 'available';
    let currency = availableCurrency.currency.toLowerCase();

    balances[currency] = balances[currency] || {};
    balances[currency][key] = balances[currency][key] || 0;
    balances[currency][key] += availableCurrency.available;
  }
  return balances;
}


/*
 * @function setSourceTransactionForWithdrawalDetails
 *
 * Iterates over an array of withdrawalDetail transactions and sets their source_transaction_id to the
 * appropriate masterWithdrawalId for that group of details.
 *
 * @param{string} masterWithdrawalId - The id of the master withdrawal for these details.
 * @param{array} withdrawalDetails - Array of withdrawal_detail transactions that make up the master withdrawal. Think
 * of these as line items of a receipt, each one represents the total amount in a given currency that was used for the
 * master withdrawal.
 * @returns{array} The modified array of withdrawal details with source_transaction_id set.
 */
function * setSourceTransactionForWithdrawalDetails (masterWithdrawalId, withdrawalDetails) {
  return yield _(withdrawalDetails).forEach(detail => {
    detail.source_transaction_id = masterWithdrawalId.toString();
  }).value();
}

/*
* @function prepareWithdrawalsForOmintoPayment
*
* Takes in an array of withdrawal detail transactions and calculates proper values to use
* for a payment of the given amount.
*
* @params {object} details - Array of withdrawal details
* @params {amount} - The amount for the purchase
* @params {object} - The context object, mostly used for logging here
*
* @returns The withdrawal objects with converted values to total the amount after conversions or
* empty array if insufficient funds.
*/
function * prepareWithdrawalsForOmintoPayment (withdrawalDetails, availableDetails, amount, ctx) {
  let len = withdrawalDetails.length;
  let sortedDetails = _.sortBy(withdrawalDetails, 'amount_to_user');
  let withdrawalsToUse = [];
  let updatedAmount;
  for (let i = 0; i < len; i++) {
    if (updatedAmount === 0) return withdrawalsToUse;
    if (!updatedAmount) {
      updatedAmount = amount;
    }
    let details = yield currency.subtractFromCurrency(sortedDetails[i].currency, sortedDetails[i].currency, availableDetails.amount, updatedAmount, ctx);
    updatedAmount = details.remaining;
    sortedDetails[i].amount_to_user = details.subtracted * -1;
    sortedDetails[i].source_type = 'ominto';
    withdrawalsToUse.push(sortedDetails[i]);
  }
  if (updatedAmount > 0) {
    return []; //Insufficient funds
  }
  return withdrawalsToUse;
}

/*
* @function getBalanceForUser
*
* Retrieves available and pending balances for all currencies the user associated to the userId has.
*
* @param {string} userId - The id of the user associated to the balances.
* @param {object} ctx - The context object, used for error handling and logging here.
*
* @returns {array | object} Array of objects or object containing balances for each currency
* <pre><code>
* [{currency: 'usd', available: 100, pending: 200}, {currency: 'eur', available: 2, pending: 23}]
* </code></pre>
*/
function * getBalanceForUser (userId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getBalanceForUser/' + userId + '/', ctx));
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getBalanceForUser', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}

function * getVipCashBackForUser (userId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getVipCashBackForUser/' + userId + '/', ctx));
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getVipCashBackForUser', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}

function * getRegularCashBackForUser (userId, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/getRegularCashBackForUser/' + userId + '/', ctx));
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during getRegularCashBackForUser', {
    res: result,
    userId: userId,
    internalCode: 351
  });
  return result.body;
}

/*
* @function getLocalizedBalanceForUser
*
* Gets a users pending and available balances for each currency. Converts the currencies to {localizedCurrency} and
* adds a total value to the convertedBalance via adding the converted available and converted pending balances.
*
* @param {string} userId - The id of the user associated with the balances to get.
* @param {string} localizedCurrency - The currency to convert to for localization purposes.
* @param {object} ctx - The context object, used for error handling and logging here.
*
* @returns {object} containing the pending, available and total balance converted to {localizedCurrency}.
*/
function * getLocalizedBalanceForUser (userId, localizedCurrency, ctx) {
  let balance = yield getBalanceForUser(userId, ctx);
  let convertedBalance = yield currency.convertCurrencies(balance, localizedCurrency, ctx);
  convertedBalance.total = convertedBalance.pending + convertedBalance.available;
  return convertedBalance;
}

function * searchTransactions (params, ctx) {
  let result = yield dataClient.get(helpers.setRequestPayload('/searchTransactions/'  + toQueryString(params), ctx));
  ctx.assert(result.statusCode !== 404, 404, 'Transaction not found', {
    internalCode: 160
  });
  ctx.assert(result.statusCode === 200, 500, 'Unexpected result from data service during searchTransactions', {
    res: result,
    internalCode: 351
  });
  return result.body;
}

module.exports = function init (config) {
  dataClient = require('../utils').getDataClient(config.data_api.internalUrl, config.data_api.auth);
  return {
    createTransaction: createTransaction,
    reassignTransactions: reassignTrasnactions,
    patchTransaction: patchTransaction,
    getTransactionById: getTransactionById,
    getTransactionByIdForUser: getTransactionByIdForUser,
    getAllTransactionIdsForUser: getAllTransactionIdsForUser,
    getAllTransactionsForUser: getAllTransactionsForUser,
    searchUserTransactions: searchUserTransactions,
    getUserFromSourceTxnId: getUserFromSourceTxnId,
    createWithdrawalRequestBody: createWithdrawalRequestBody,
    lockWithdrawal: lockWithdrawal,
    unlockWithdrawal: unlockWithdrawal,
    determineFromCurrency: determineFromCurrency,
    getAvailableBalanceForWithdrawalForUserByCurrencies: getAvailableBalanceForWithdrawalForUserByCurrencies,
    aggregateAvailableBalance: aggregateAvailableBalance,
    getAvailableBalanceForWithdrawalForUserByCurrenciesForOmintoPayment: getAvailableBalanceForWithdrawalForUserByCurrenciesForOmintoPayment,
    aggregateAvailableBalanceForOmintoPayment: aggregateAvailableBalanceForOmintoPayment,
    setSourceTransactionForWithdrawalDetails: setSourceTransactionForWithdrawalDetails,
    createTransactionsForWithdrawal: createTransactionsForWithdrawal,
    createWithdrawalDetailTransactions: createWithdrawalDetailTransactions,
    getBalanceForUser: getBalanceForUser,
    getVipCashBackForUser: getVipCashBackForUser,
    getRegularCashBackForUser: getRegularCashBackForUser,
    getLocalizedBalanceForUser: getLocalizedBalanceForUser,
    getTransactionBySourceTransactionId: getTransactionBySourceTransactionId,
    prepareWithdrawalsForOmintoPayment: prepareWithdrawalsForOmintoPayment,
    searchTransactions: searchTransactions,
    searchBspTransactions: searchBspTransactions,
    TYPE: TYPE
  };
};
