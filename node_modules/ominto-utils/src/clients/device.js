'use strict';

let dataClient;

module.exports = function init (config, data) {
  // allowing the dataclient to be injected here is just to avoid having to re-write
  // so many tests which rely on stubbing methods of the dataclient via sinon
  if (data) {
    dataClient = data;
  } else {
    dataClient = require('../utils/rest-client')(config.data_api, false);
  }

  return {
    createDevice: createDevice,
    getDeviceByDeviceId: getDeviceByDeviceId,
    changeDevicePin: changeDevicePin,
    assignDeviceToUser: assignDeviceToUser,
    assignUsersDevicesToNewUser: assignUsersDevicesToNewUser,
    deleteDevice: deleteDevice
  };
};

function * createDevice (device, ctx) {
  try {
    let result = yield dataClient.post('/createDevice/', device, ctx);
    return result.body;
  } catch (e) {
    // check for duplicate unique key
    if (e.code === 'ER_DUP_ENTRY') {
      ctx.throw(400, 'Unique field already in use', {
        internalCode: 52,
        duplicateKey: true,
        duplicateMsg: e.message
      });
    }
  }
}

function * getDeviceByDeviceId (deviceId, bypassCache, ctx) {
  let result = yield dataClient.get('/getDeviceByDeviceId/' + deviceId + '/', {bypass: bypassCache}, ctx);
  ctx.assert(result.statusCode !== 404, 404, 'Device not found', {internalCode: 120});
  return result.body;
}

function * changeDevicePin (deviceId, newPin, ctx) {
  yield dataClient.patch('/changeDevicePin/', {device_id: deviceId, pin: newPin}, ctx);
}

function * assignDeviceToUser (userId, deviceId, ctx) {
  yield dataClient.patch('/assignDeviceToUser/', {id: deviceId, user_id: userId}, ctx);
}

function * assignUsersDevicesToNewUser (idToKeep, idToReplace, ctx) {
  yield dataClient.patch('/assignUsersDevicesToNewUser/', {idToKeep: idToKeep, idToReplace: idToReplace}, ctx);
}

function * deleteDevice (deviceId, ctx) {
  let result = yield dataClient.del('/deleteDeviceById/' + deviceId + '/', ctx);
  return result.body;
}
